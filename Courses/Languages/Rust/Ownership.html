<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"/> <meta name="viewport" content="width=device-width,initial-scale=1"/> <title>Ownership</title> <link rel="stylesheet" href="https://grimoire.quantinium.dev/static/styles.css"/> <link rel="icon" href="/static/pfp.svg"/> <meta property="og:site_name" content="Quantinium"/> <meta property="og:title" content="Ownership"/> <meta property="og:type" content="website"/> <meta name="twitter:card" content="summary_large_image"/> <meta name="twitter:title" content="Ownership"/> <meta name="og:url" content="https://grimoire.quantinium.dev/Courses/Languages/Rust/Ownership.md"/> <meta name="twitter:url" content="https://grimoire.quantinium.dev/Courses/Languages/Rust/Ownership.md"/> <meta name="generator" content="grimoire"/> <meta name="twitter:domain" content="https://grimoire.quantinium.dev/"/> <meta property="og:type" content="article"/> <meta name="keywords" content="#Rust/Ownership, #Rust/Scope, #Rust/Slices, #Rust/Strings, #Rust/Borrowing, #Rust/References, Rust"/> <link rel="canonical" href="https://grimoire.quantinium.dev/Courses/Languages/Rust/Ownership.html"/> <meta property="og:url" content="https://grimoire.quantinium.dev/Courses/Languages/Rust/Ownership.html"/> <meta property="og:image:type" content="image/png"/> <meta property="og:image:alt" content="Ownership"/> <meta property="og:image:url" content="https://grimoire.quantinium.dev/static/ownership.md573494-og.png"/> <meta property="og:image" content="https://grimoire.quantinium.dev/static/ownership.md573494-og.png"/> <meta property="og:image:width" content="1200"/> <meta property="og:image:height" content="630"/> <meta name="twitter:image" content="https://grimoire.quantinium.dev/static/ownership.md573494-og.png"/> <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.1.0"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js" integrity="sha512-GsLlZN/3F2ErC5ifS5QtgpiJtWd43JWSuIgh7mbzZ8zBps+dvLusV+eNQATqgA/HdeKFVgA5v3S/cIrLF7QnIg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script> <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/regular/style.css"/> <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/@phosphor-icons/web@2.1.1/src/fill/style.css"/> </head> <body> <div class="container"> <div class="sidebar"> <div class="sidebar-inner"> <h1 class="owner"><a href="/">Quantinium</a></h1> <div class="sidebar-theme-toggle"> <button class="theme-toggle" onclick="toggleTheme(!0)" aria-label="Toggle Theme"> <i class="ph ph-sun"></i> </button> <button class="search-button" onclick="openSearch()" aria-label="Open Search"> <i class="ph ph-magnifying-glass"></i> </button> <button class="pdf-button" onclick="printPage()" aria-label="Print Page"> <i class="ph ph-file-pdf"></i> </button> </div> <div id="file-tree" class="file-tree"></div> <div class="divider" draggable="true"></div> </div> </div> <div class="content" role="main"> <nav class="top-navbar"> <div class="top-navbar-left"> <button class="sidebar-toggle" onclick="toggleNav()" aria-label="Toggle Sidebar"> <i class="ph ph-list"></i> </button> <img class="profile-picture" src="/static/pfp.svg" alt="pfp"/> <a href="/">Quantinium</a> </div> <div class="top-navbar-right"> <button class="search-button" onclick="openSearch()" aria-label="Open Search"> <i class="ph ph-magnifying-glass"></i> </button> <button class="theme-toggle" onclick="toggleTheme(!0)" aria-label="Toggle Theme"> <i class="ph ph-sun"></i> </button> <button class="pdf-button" onclick="printPage()" aria-label="Print Page"> <i class="ph ph-file-pdf"></i> </button> </div> </nav> <div class="content-container"> <div class="content-container-inner"> <div class="page-content"> <h1>Ownership</h1> <div class="page-tags"> <span class="tag">#Rust/Ownership</span> <span class="tag">#Rust/Scope</span> <span class="tag">#Rust/Slices</span> <span class="tag">#Rust/Strings</span> <span class="tag">#Rust/Borrowing</span> <span class="tag">#Rust/References</span> <span class="tag">Rust</span> </div> <article class="markdown-content"> <p>Ownership is Rust's way of managing memory safety without a garbage collector. It enforces strict rules at compile time to ensure memory safety, prevent data races, and eliminate common bugs like null pointer dereferencing or use-after-free errors.</p> <h3 id="stack-and-heap">Stack and Heap</h3> <p>The stack and heap are two regions of memory used for different purposes in a program. They differ in how memory is allocated, accessed, and managed.</p> <h4 id="stack--">Stack -</h4> <ul> <li><strong>Structure</strong>: The stack is a LIFO (Last-In, First-Out) data structure. It grows and shrinks automatically as functions are called and return.</li> <li><strong>Allocation</strong>: Memory is allocated in a contiguous block. Each function call creates a new stack frame, which contains local variables, function parameters, and return addresses.</li> <li><strong>Speed</strong>: Extremely fast because memory allocation and deallocation are just pointer adjustments.</li> <li><strong>Size</strong>: Limited in size (typically a few MB per thread).</li> <li><strong>Lifetime</strong>: Memory is automatically reclaimed when a function returns (its stack frame is popped).</li> <li><strong>Use Case</strong>: Ideal for small, fixed-size data with predictable lifetimes (e.g., local variables, function arguments).</li> </ul> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// `x` is stored on the stack</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// `y` is stored on the stack</span>
</span><span class="code-line line-number" line="4">    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Function call creates a new stack frame</span>
</span><span class="code-line line-number" line="5">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"Sum: {}"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="7">
</span><span class="code-line line-number" line="8"><span class="token keyword">fn</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">i32</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="9">    a <span class="token operator">+</span> b <span class="token comment">// `a` and `b` are stored on the stack</span>
</span><span class="code-line line-number" line="10"><span class="token punctuation">}</span>
</span></code></pre> <h4 id="heap--">Heap -</h4> <ul> <li><strong>Structure</strong>: The heap is a more flexible memory region where data can be allocated and freed in any order.</li> <li><strong>Allocation</strong>: Memory is allocated dynamically at runtime. You request a block of memory of a specific size, and the memory manager finds a suitable spot.</li> <li><strong>Speed</strong>: Slower than the stack because it involves finding and managing memory blocks.</li> <li><strong>Size</strong>: Much larger than the stack (limited by available system memory).</li> <li><strong>Lifetime</strong>: Memory must be explicitly allocated and deallocated (or managed by a garbage collector or ownership system, as in Rust).</li> <li><strong>Use Case</strong>: Ideal for data with dynamic size or unpredictable lifetimes (e.g., strings, collections, or large objects).</li> </ul> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// `s` is stored on the heap</span>
</span><span class="code-line line-number" line="3">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4"><span class="token punctuation">}</span>
</span></code></pre> <h3 id="the-three-rules-of-ownership">The Three Rules of Ownership</h3> <ul> <li><strong>Each value in Rust has a single owner.</strong> - <ul> <li>At any given time, a piece of data is owned by exactly one variable.</li> <li>When the owner goes out of scope, the value is dropped (memory is freed).</li> </ul> </li> <li><strong>There can only be one owner at a time.</strong> <ul> <li>If you assign a value to another variable or pass it to a function, the ownership is <em>moved</em>. The original owner no longer has access to the value.</li> </ul> </li> <li><strong>Ownership can be borrowed, but with strict rules.</strong> - <ul> <li>Instead of transferring ownership, you can create references to the value. These references can be either: <ul> <li><strong>Immutable references (<code>&#x26;T</code>)</strong>: Multiple immutable references are allowed, but no mutable references can exist simultaneously.</li> <li><strong>Mutable references (<code>&#x26;mut T</code>)</strong>: Only one mutable reference is allowed at a time, and no immutable references can coexist.</li> </ul> </li> </ul> </li> </ul> <h3 id="variable-scope">Variable Scope</h3> <p>Variable scope refers to the region of code where a variable is valid and can be accessed. It is defined by where the variable is declared and how long it lives in memory.</p> <ul> <li>Block Scope</li> </ul> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token punctuation">{</span>   <span class="token comment">// s is not valid here, it’s not yet declared </span>
</span><span class="code-line line-number" line="2">	<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// s is valid from this point forward </span>
</span><span class="code-line line-number" line="3">	<span class="token comment">// do stuff with s </span>
</span><span class="code-line line-number" line="4"><span class="token punctuation">}</span> 
</span><span class="code-line line-number" line="5"><span class="token comment">// this scope is now over, and s is no longer valid</span>
</span></code></pre> <h3 id="string-type">String Type</h3> <ul> <li><strong>String Literals vs. <code>String</code> Type</strong> <ul> <li><strong>String literals</strong>: Immutable, hardcoded text stored in the program's binary.</li> <li><strong><code>String</code> type</strong>: Mutable, dynamically allocated on the heap, and can store text of unknown size at compile time (e.g., user input).</li> </ul> </li> <li><strong>Creating a <code>String</code></strong> <ul> <li>Use the <code>String::from</code> function to create a <code>String</code> from a string literal:</li> </ul> </li> </ul> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre> <ul> <li> <ul> <li><strong>Ownership and Heap Memory</strong> <ul> <li>The <code>String</code> type owns its heap-allocated data.</li> <li>When a <code>String</code> goes out of scope, Rust automatically frees the memory (no manual memory management or garbage collection needed)</li> </ul> </li> </ul> </li> </ul> <p><code>String</code> can be mutated as they are heap allocated and we can append a string literal at the end of it. This isnt possible with string literals as they are hardcoded in programs binary.</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1">    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="2">    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">", world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// push_str() appends a literal to a String</span>
</span><span class="code-line line-number" line="3">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{s}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This will print `hello, world!`</span>
</span></code></pre> <h3 id="memory-allocation">Memory Allocation</h3> <p>There are two well know and most used ways to allocate data on the heap.</p> <h4 id="manual-memory-management">Manual Memory Management</h4> <ul> <li><strong>How it works</strong>:<br> Developers explicitly allocate and deallocate memory using functions like <code>malloc</code> (in C) or <code>new</code>/<code>delete</code> (in C++). <ul> <li><strong>Allocation</strong>: Request memory from the heap using <code>malloc</code> or similar functions.</li> <li><strong>Deallocation</strong>: Free memory using <code>free</code> or similar functions when it’s no longer needed.</li> </ul> </li> </ul> <pre class="language-c"><code class="language-c code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">int</span><span class="token operator">*</span> arr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Allocate memory for 10 integers</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="3">    <span class="token comment">// Handle allocation failure</span>
</span><span class="code-line line-number" line="4"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="5"><span class="token comment">// Use the array</span>
</span><span class="code-line line-number" line="6"><span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Free the memory when done</span>
</span></code></pre> <ul> <li><strong>Pros</strong>: <ul> <li>Full control over memory allocation and deallocation.</li> <li>Predictable performance (no garbage collection pauses).</li> </ul> </li> <li><strong>Cons</strong>: <ul> <li>Error-prone: Forgetting to free memory leads to <strong>memory leaks</strong>.</li> <li>Freeing memory too early leads to <strong>dangling pointers</strong>.</li> <li>Freeing memory twice leads to <strong>undefined behavior</strong></li> </ul> </li> </ul> <h4 id="garbage-collection-gc"><strong>Garbage Collection (GC)</strong></h4> <ul> <li><strong>How it works</strong>:<br> The runtime system (e.g., in Java, Python, or Go) automatically tracks memory usage and reclaims memory that is no longer referenced by the program. <ul> <li><strong>Reference Counting</strong>: Counts references to objects and frees memory when the count drops to zero (used in Python).</li> <li><strong>Tracing GC</strong>: Periodically scans the heap to identify unreachable objects (used in Java, Go).</li> </ul> </li> </ul> <pre class="language-python"><code class="language-python code-highlight"><span class="code-line line-number" line="1">s <span class="token operator">=</span> <span class="token string">"hello"</span>  <span class="token comment"># Memory is allocated automatically</span>
</span><span class="code-line line-number" line="2">s <span class="token operator">=</span> <span class="token string">"world"</span>  <span class="token comment"># Old string "hello" is garbage collected</span>
</span></code></pre> <ul> <li><strong>Pros</strong>: <ul> <li>No manual memory management required.</li> <li>Prevents memory leaks, dangling pointers, and double-free errors.</li> </ul> </li> <li><strong>Cons</strong>: <ul> <li>Overhead: GC introduces runtime performance costs (e.g., pauses for tracing).</li> <li>Less control: Developers can’t predict exactly when memory will be freed.</li> </ul> </li> </ul> <h4 id="rusts-approach-ownership-and-borrowing">Rust’s Approach: Ownership and Borrowing</h4> <p>Rust takes a unique approach that combines the best of both worlds:</p> <ul> <li><strong>No Garbage Collector</strong>: Rust avoids runtime overhead by not using a GC.</li> <li><strong>No Manual Memory Management</strong>: Rust enforces strict compile-time rules (ownership, borrowing, and lifetimes) to ensure memory safety.</li> </ul> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4"><span class="token punctuation">}</span>
</span></code></pre> <p>Here we can guess that <code>x</code> is being bound to 5 and the for y we make a copy of <code>x</code> and store it in y. This is how it happens for integers, floats, etc cause these are small data types and all can be done on compile time.</p> <p>For example the assembly of this may look like this.</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1">mov dword ptr <span class="token punctuation">[</span>rsp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span> 
</span><span class="code-line line-number" line="2">mov dword ptr <span class="token punctuation">[</span>rsp <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span>
</span><span class="code-line line-number" line="3">ret
</span></code></pre> <p>The compiler being an intelligent being know the value of <code>x</code> is 5 so it just make two variable with value <code>5</code>.</p> <p>But in case of data structures such as <code>String</code> this isn't possible as we don't know what the size of the <code>String</code> needs to be cause the user may append string literal</p> <p><img src="https://doc.rust-lang.org/stable/book/img/trpl04-01.svg" alt="string_representation"> As we can see in this, A string <code>s1</code> is made up of three parts - pointer to address on heap, length of string and the total capacity of string. These are stored on the stack.</p> <p>When we assign <code>s1 = s2</code> ,  we copy the pointer, the length, and the capacity that are on the stack.</p> <p><img src="https://doc.rust-lang.org/stable/book/img/trpl04-02.svg" alt="string_assignment"></p> <p>Now if we cloned string <code>s1</code> and then assigned that to <code>s2</code> we would have the following representation: <img src="https://doc.rust-lang.org/stable/book/img/trpl04-03.svg" alt="string_clone"> There cloning is considered an expensive process as we have to allocate new memory in the heap for the new string. If we don't clone the ownership of the <code>s1</code> is transferred to <code>s2</code> not making this an expensive operation due to no heap allocations.</p> <p>There its generally not recommended to clone a data as that can be an expensive operation.</p> <p>The operation of <code>s1 = s2</code> may sound like shallow copy in other languages as we copy the stack data but in Rust we invalidate <code>s1</code> , therefore it is called a <code>move</code> operation. <code>s1</code> was moved into <code>s2</code>.</p> <h2 id="scope-and-assignment">Scope and Assignment</h2> <p>In Rust, when you assign a new value to an existing variable, Rust automatically calls the <code>drop</code> function to free the memory of the original value immediately. For example, in the code:</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</span><span class="code-line line-number" line="2">s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"ahoy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</span><span class="code-line line-number" line="3"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{s}, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre> <p>In Rust, if you need to create a <strong>deep copy</strong> of heap data (not just the stack data like pointers, length, and capacity), you can use the <code>clone</code> method. For example:</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {s1}, s2 = {s2}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre> <ul> <li>The <code>clone</code> method creates a full copy of the <code>String</code>'s heap data, so both <code>s1</code> and <code>s2</code> are independent and valid.</li> <li>This is different from a move or shallow copy, as <code>clone</code> explicitly duplicates the data, allowing both variables to coexist.</li> </ul> <p>In Rust, certain types, like integers, have a known size at compile time and are stored entirely on the stack. For these types, copying the value is fast and straightforward, so Rust automatically performs a <strong>trivial copy</strong> instead of a move. This means that after assigning one variable to another, both variables remain valid. For example:</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3"><span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"x = {x}, y = {y}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre> <p>Here, <code>x</code> and <code>y</code> are both valid because the value <code>5</code> is copied, not moved. This behavior is enabled by the <strong><code>Copy</code> trait</strong>, which is automatically implemented for types that can be stored entirely on the stack. Example :</p> <ul> <li>All the integer types, such as <code>u32</code>.</li> <li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li> <li>All the floating-point types, such as <code>f64</code>.</li> <li>The character type, <code>char</code>.</li> <li>Tuples, if they only contain types that also implement <code>Copy</code>. For example, <code>(i32, i32)</code> implements <code>Copy</code>, but <code>(i32, String)</code> does not.</li> </ul> <h2 id="ownership-and-functions">Ownership and Functions</h2> <p>In Rust, passing a value to a function follows the same ownership rules as assigning a value to a variable.</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s comes into scope</span>
</span><span class="code-line line-number" line="3">
</span><span class="code-line line-number" line="4">    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s's value moves into the function...</span>
</span><span class="code-line line-number" line="5">                                    <span class="token comment">// ... and so is no longer valid here</span>
</span><span class="code-line line-number" line="6">
</span><span class="code-line line-number" line="7">    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x comes into scope</span>
</span><span class="code-line line-number" line="8">
</span><span class="code-line line-number" line="9">    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x would move into the function,</span>
</span><span class="code-line line-number" line="10">                                    <span class="token comment">// but i32 is Copy, so it's okay to still</span>
</span><span class="code-line line-number" line="11">                                    <span class="token comment">// use x afterward</span>
</span><span class="code-line line-number" line="12">
</span><span class="code-line line-number" line="13"><span class="token punctuation">}</span> <span class="token comment">// Here, x goes out of scope, then s. But because s's value was moved, nothing</span>
</span><span class="code-line line-number" line="14">  <span class="token comment">// special happens.</span>
</span><span class="code-line line-number" line="15">
</span><span class="code-line line-number" line="16"><span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_string comes into scope</span>
</span><span class="code-line line-number" line="17">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{some_string}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="18"><span class="token punctuation">}</span> <span class="token comment">// Here, some_string goes out of scope and `drop` is called. The backing</span>
</span><span class="code-line line-number" line="19">  <span class="token comment">// memory is freed.</span>
</span><span class="code-line line-number" line="20">
</span><span class="code-line line-number" line="21"><span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_integer comes into scope</span>
</span><span class="code-line line-number" line="22">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{some_integer}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="23"><span class="token punctuation">}</span> <span class="token comment">// Here, some_integer goes out of scope. Nothing special happens.</span>
</span></code></pre> <h3 id="return-values-and-scopes">Return values and scopes</h3> <p>Returning a value can transfer ownership cause we are returning the value from the function.</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// gives_ownership moves its return</span>
</span><span class="code-line line-number" line="3">                                        <span class="token comment">// value into s1</span>
</span><span class="code-line line-number" line="4">
</span><span class="code-line line-number" line="5">    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// s2 comes into scope</span>
</span><span class="code-line line-number" line="6">
</span><span class="code-line line-number" line="7">    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s2 is moved into</span>
</span><span class="code-line line-number" line="8">                                        <span class="token comment">// takes_and_gives_back, which also</span>
</span><span class="code-line line-number" line="9">                                        <span class="token comment">// moves its return value into s3</span>
</span><span class="code-line line-number" line="10"><span class="token punctuation">}</span> <span class="token comment">// Here, s3 goes out of scope and is dropped. s2 was moved, so nothing</span>
</span><span class="code-line line-number" line="11">  <span class="token comment">// happens. s1 goes out of scope and is dropped.</span>
</span><span class="code-line line-number" line="12">
</span><span class="code-line line-number" line="13"><span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span>             <span class="token comment">// gives_ownership will move its</span>
</span><span class="code-line line-number" line="14">                                             <span class="token comment">// return value into the function</span>
</span><span class="code-line line-number" line="15">                                             <span class="token comment">// that calls it</span>
</span><span class="code-line line-number" line="16">
</span><span class="code-line line-number" line="17">    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"yours"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string comes into scope</span>
</span><span class="code-line line-number" line="18">
</span><span class="code-line line-number" line="19">    some_string                              <span class="token comment">// some_string is returned and</span>
</span><span class="code-line line-number" line="20">                                             <span class="token comment">// moves out to the calling</span>
</span><span class="code-line line-number" line="21">                                             <span class="token comment">// function</span>
</span><span class="code-line line-number" line="22"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="23">
</span><span class="code-line line-number" line="24"><span class="token comment">// This function takes a String and returns one</span>
</span><span class="code-line line-number" line="25"><span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token comment">// a_string comes into</span>
</span><span class="code-line line-number" line="26">                                                      <span class="token comment">// scope</span>
</span><span class="code-line line-number" line="27">
</span><span class="code-line line-number" line="28">    a_string  <span class="token comment">// a_string is returned and moves out to the calling function</span>
</span><span class="code-line line-number" line="29"><span class="token punctuation">}</span>
</span></code></pre> <p>This way of giving ownership and taking back ownership of the variable by returning seems tedious therefore we use references to deal with this.</p> <h2 id="references-and-borrowing">References and Borrowing</h2> <p>Instead of returning a tuple from a function to be able to use that variable again we will pass it as a reference to the function.</p> <blockquote> <p> A <em>reference</em> is like a pointer in that it’s an address we can follow to access the data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.</p> </blockquote> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">let</span> len <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span><span class="token operator">&#x26;</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4">    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"The length of '{s1}' is {len}."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="6">
</span><span class="code-line line-number" line="7"><span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token operator">&#x26;</span><span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="8">    s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="9"><span class="token punctuation">}</span>
</span></code></pre> <p>In the above example we pass reference of <code>s1</code> to <code>calculate length</code> , therefore we are able to use it the function without the variable being dropped when function finishes running as the <code>s1</code> owner is still the main function.</p> <p>We call the action of creating a reference <em>borrowing</em>. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back. You don’t own it.</p> <p>There are two types of references:</p> <ul> <li><strong>Immutable Reference (<code>&#x26;T</code>)</strong> - <ul> <li>An immutable reference allows you to read the data but not modify it.</li> <li>Multiple immutable references to the same data are allowed at the same time.</li> </ul> </li> <li><strong>Mutable Reference (<code>&#x26;mut T</code>)</strong> <ul> <li> <ul> <li>A mutable reference allows you to read and modify the data.</li> </ul> </li> <li>Only one mutable reference to a particular piece of data is allowed at a time (no other references, mutable or immutable, can exist simultaneously).</li> </ul> </li> </ul> <p>Once caveat of mutable references have one big restriction that you cant make more than one mutable references as this can cause data races but we can have as many immutable references as we want.</p> <h3 id="dangling-references">Dangling references</h3> <p>In languages like C or C++ it's really easy to create dangling pointers. In Rust,  the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">fn</span> <span class="token function-definition function">dangle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">&#x26;</span><span class="token class-name">String</span> <span class="token punctuation">{</span> <span class="token comment">// dangle returns a reference to a String</span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3">    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s is a new String</span>
</span><span class="code-line line-number" line="4">
</span><span class="code-line line-number" line="5">    <span class="token operator">&#x26;</span>s <span class="token comment">// we return a reference to the String, s</span>
</span><span class="code-line line-number" line="6"><span class="token punctuation">}</span> <span class="token comment">// Here, s goes out of scope, and is dropped. Its memory goes away.</span>
</span><span class="code-line line-number" line="7">  <span class="token comment">// Danger!</span>
</span></code></pre> <h3 id="the-rules-of-references">The Rules of References</h3> <p>The rules of references -</p> <ul> <li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li> <li>References must always be valid.</li> </ul> <h2 id="slices">Slices</h2> <p><em>Slices</em> let you reference a contiguous sequence of elements in a <a href="https://doc.rust-lang.org/stable/book/ch08-00-common-collections.html">collection</a> rather than the whole collection. A slice is a kind of reference, so it does not have ownership.</p> <h3 id="string-slices">String slices</h3> <p>A <em>string slice</em> is a reference to part of a <code>String</code>, and it looks like this:</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1">    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3">    <span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token operator">&#x26;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4">    <span class="token keyword">let</span> world <span class="token operator">=</span> <span class="token operator">&#x26;</span>s<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">..</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span></code></pre> <p>Rather than a reference to the entire <code>String</code>, <code>hello</code> is a reference to a portion of the <code>String</code>, specified in the extra <code>[0..5]</code> bit. We create slices using a range within brackets by specifying <code>[starting_index..ending_index]</code>, where <code>starting_index</code> is the first position in the slice and <code>ending_index</code> is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to <code>ending_index</code> minus <code>starting_index</code>.</p> <p><img src="https://doc.rust-lang.org/stable/book/img/trpl04-07.svg" alt="slice_representation"></p> <blockquote> <p>String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.</p> </blockquote> <h4 id="string-literals-as-slices">String literals as slices</h4> <p>As we know that string literals are stored inside the binary</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>
</span></code></pre> <p>The type of <code>s</code> here is <code>&#x26;str</code>: it’s a slice pointing to that specific point of the binary. This is also why string literals are immutable; <code>&#x26;str</code> is an immutable reference.</p> <h4 id="other-parameters">Other parameters</h4> <p>String slices, as you might imagine, are specific to strings. But there’s a more general slice type too. Consider this array:</p> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span></code></pre> <pre class="language-rust"><code class="language-rust code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">let</span> slice <span class="token operator">=</span> <span class="token operator">&#x26;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3"><span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> <span class="token operator">&#x26;</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code></pre> <p>This slice has the type <code>&#x26;[i32]</code>. It works the same way as string slices do, by storing a reference to the first element and a length</p> </article> </div> </div> </div> <div class="container-right"> <h3 class="table-of-content">Table of Contents</h3> <div class="container-right-inner"> <nav class="toc"><ul><ul><ul><li class="toc-level-3"><a href="#stack-and-heap">Stack and Heap</a><ul><li class="toc-level-4"><a href="#stack--">Stack -</a></li><li class="toc-level-4"><a href="#heap--">Heap -</a></li></ul></li><li class="toc-level-3"><a href="#the-three-rules-of-ownership">The Three Rules of Ownership</a></li><li class="toc-level-3"><a href="#variable-scope">Variable Scope</a></li><li class="toc-level-3"><a href="#string-type">String Type</a></li><li class="toc-level-3"><a href="#memory-allocation">Memory Allocation</a><ul><li class="toc-level-4"><a href="#manual-memory-management">Manual Memory Management</a></li><li class="toc-level-4"><a href="#garbage-collection-gc">Garbage Collection (GC)</a></li><li class="toc-level-4"><a href="#rusts-approach-ownership-and-borrowing">Rust’s Approach: Ownership and Borrowing</a></li></ul></li></ul><li class="toc-level-2"><a href="#scope-and-assignment">Scope and Assignment</a></li><li class="toc-level-2"><a href="#ownership-and-functions">Ownership and Functions</a><ul><li class="toc-level-3"><a href="#return-values-and-scopes">Return values and scopes</a></li></ul></li><li class="toc-level-2"><a href="#references-and-borrowing">References and Borrowing</a><ul><li class="toc-level-3"><a href="#dangling-references">Dangling references</a></li><li class="toc-level-3"><a href="#the-rules-of-references">The Rules of References</a></li></ul></li><li class="toc-level-2"><a href="#slices">Slices</a><ul><li class="toc-level-3"><a href="#string-slices">String slices</a><ul><li class="toc-level-4"><a href="#string-literals-as-slices">String literals as slices</a></li><li class="toc-level-4"><a href="#other-parameters">Other parameters</a></li></ul></li></ul></li></ul></ul></nav> </div> </div> </div> </div> <div class="keybinding"> <ul></ul> </div> <div class="search-dialog" id="search-dialog"> <div class="search-dialog-content"> <input type="text" id="search-input" placeholder="search..." autocomplete="off"/> <button class="close-search" onclick="closeSearch()" aria-label="Close Search"><i class="ph ph-x"></i></button> <div id="search-results" class="search-results"></div> </div> </div> <script>function keybindingInitialize(){let n=document.querySelector(".keybinding ul");var e;n&&(n.innerHTML="",[{key:"j",desc:"Scroll down"},{key:"k",desc:"Scroll up"},{key:"gg/Home",desc:"Scroll to top"},{key:"Shift+G/End",desc:"Scroll to bottom"},{key:"Ctrl+D",desc:"Scroll half screen down"},{key:"Ctrl+U",desc:"Scroll half screen up"},{key:"Shift+T",desc:"Toggle theme"},{key:"/",desc:"Open search"},{key:"Esc",desc:"Clear focus/close help"},{key:"Shift+H",desc:"Toggle this help"}].forEach(e=>{var t=document.createElement("li");t.textContent=e.key+" - "+e.desc,n.appendChild(t)}),document.head.appendChild(style),keybinding.classList.add("hidden"),(e=document.createElement("h4")).textContent="Keyboard Shortcuts",n.parentNode.insertBefore(e,n))}function printPage(){var e=document.querySelector(".content-container");html2pdf(e)}function initializeFileTree(e){var n=document.getElementById("file-tree");if(n){let s="fileTreeExpandedState",d=new Map(JSON.parse(localStorage.getItem(s))||[]),t=document.createElement("ul");function l(n,e=""){var a=document.createElement("ul"),i=document.createElement("li");i.classList.add(n.type),a.appendChild(i);let r=e?e+"/"+n.name:n.name;if("directory"===n.type&&0<n.children.length){a=document.createElement("div"),e=(a.classList.add("directory-wrapper"),a.style.display="flex",a.style.alignItems="center",document.createElement("i")),e=(e.setAttribute("class","ph ph-caret-right directory-arrow"),a.appendChild(e),document.createElement("span"));e.setAttribute("class","dirname"),e.textContent=n.name.replaceAll("_"," ").replaceAll("-"," ").replace(".md",""),a.appendChild(e),i.appendChild(a);let t=document.createElement("ul");d.get(r)||!1?i.classList.add("open"):t.classList.add("collapsed"),n.children.forEach(e=>{e=l(e,r);t.appendChild(e)}),a.addEventListener("click",function(e){e.stopPropagation();var e=this.parentNode,t=e.classList.toggle("open");e.querySelector("ul").classList.toggle("collapsed"),d.set(r,t),localStorage.setItem(s,JSON.stringify([...d]))}),i.appendChild(t)}else"file"===n.type&&(i.textContent=n.name.replace(".md",""),i.addEventListener("click",function(e){e.stopPropagation();e=n.path.replace(/\.md$/,".html");window.location.href="/"+e}));return i}e.forEach(e=>{t.appendChild(l(e))}),n.appendChild(t)}}function toggleNav(){document.querySelector(".sidebar").classList.toggle("open")}function openSearch(){document.querySelector(".search-dialog").classList.add("open"),setTimeout(()=>{document.getElementById("search-input").focus()},100)}function toggleTheme(e=!1){let t=localStorage.getItem("theme");t||(t="dark",localStorage.setItem("theme","dark")),e&&(t="dark"===t?"light":"dark",localStorage.setItem("theme",t));e=document.body;"dark"===t?(e.classList.remove("light"),e.classList.add("dark")):"light"===t&&(e.classList.remove("dark"),e.classList.add("light"))}function initializeCopyButton(){document.querySelectorAll(".content-container-inner pre").forEach(t=>{let n=document.createElement("button");n.textContent="Copy",n.classList.add("copy-button"),n.addEventListener("click",()=>{var e=t.querySelector("code")?.textContent||t.textContent;navigator.clipboard.writeText(e).then(()=>{n.textContent="Copied!",setTimeout(()=>{n.textContent="Copy"},2e3)}).catch(e=>{console.error("Failed to copy:",e),n.textContent="Error!",setTimeout(()=>{n.textContent="Copy"},2e3)})}),t.appendChild(n)})}function toggleKeyHints(){var e=document.querySelector(".keybinding");e&&e.classList.toggle("hidden")}function extractNameFromUrl(e){return e?((e=e.split("/").filter(Boolean))[e.length-1]||"").replace(/\.html$|\.md$/,"").replace(/[-_]/g," ").replace(/\b\w/g,e=>e.toUpperCase()):"Untitled"}function closeSearch(){var e=document.getElementById("search-dialog");e&&(e.classList.remove("open"),(e=document.getElementById("search-input"))&&(e.value=""),e=document.getElementById("search-results"))&&(e.innerHTML="")}function displaySearchResults(t,n){if(n.innerHTML="",0===t.length)n.innerHTML='<p class="no-results">No results found.</p>';else{var e,a=Math.min(t.length,10);for(let e=0;e<a;e++){var i=t[e].item,r=document.createElement("a"),i=(r.href=i.url,i.name||extractNameFromUrl(i.url));r.textContent=i,r.addEventListener("click",closeSearch),n.appendChild(r)}t.length>a&&((e=document.createElement("p")).className="search-show-more",e.textContent=`Showing top ${a} of ${t.length} results. Refine your search for more specific results.`,n.appendChild(e))}}function handleSearch(e){var e=e.target.value.trim(),t=document.getElementById("search-results");0===e.length?t.innerHTML="":fuse&&searchIndex.length?displaySearchResults(fuse.search(e),t):t.innerHTML='<p class="search-error">Search is not initialized yet. Please wait or refresh the page.</p>'}document.addEventListener("DOMContentLoaded",async function(){try{initializeFileTree(JSON.parse('[{"name":"Cheat_Sheets","path":"Cheat_Sheets","type":"directory","children":[{"name":"ansi_color_codes.md","path":"Cheat_Sheets/ansi_color_codes.md","type":"file","children":[]},{"name":"Git.md","path":"Cheat_Sheets/Git.md","type":"file","children":[]},{"name":"ssh_android_to_pc.md","path":"Cheat_Sheets/ssh_android_to_pc.md","type":"file","children":[]}]},{"name":"Courses","path":"Courses","type":"directory","children":[{"name":"Boot_Dev","path":"Courses/Boot_Dev","type":"directory","children":[{"name":"HTTP.md","path":"Courses/Boot_Dev/HTTP.md","type":"file","children":[]}]},{"name":"CSES","path":"Courses/CSES","type":"directory","children":[{"name":"Complete_Search.md","path":"Courses/CSES/Complete_Search.md","type":"file","children":[]},{"name":"Data_Structures.md","path":"Courses/CSES/Data_Structures.md","type":"file","children":[]}]},{"name":"Data_Structures_and_algorithms","path":"Courses/Data_Structures_and_algorithms","type":"directory","children":[{"name":"backtracking.md","path":"Courses/Data_Structures_and_algorithms/backtracking.md","type":"file","children":[]},{"name":"linear_data_structure.md","path":"Courses/Data_Structures_and_algorithms/linear_data_structure.md","type":"file","children":[]},{"name":"tree.md","path":"Courses/Data_Structures_and_algorithms/tree.md","type":"file","children":[]}]},{"name":"Languages","path":"Courses/Languages","type":"directory","children":[{"name":"Go","path":"Courses/Languages/Go","type":"directory","children":[{"name":"go.md","path":"Courses/Languages/Go/go.md","type":"file","children":[]}]},{"name":"Java","path":"Courses/Languages/Java","type":"directory","children":[{"name":"Containers.md","path":"Courses/Languages/Java/Containers.md","type":"file","children":[]},{"name":"Data_Types.md","path":"Courses/Languages/Java/Data_Types.md","type":"file","children":[]},{"name":"Expression_Statements.md","path":"Courses/Languages/Java/Expression_Statements.md","type":"file","children":[]},{"name":"Garbage_Collection.md","path":"Courses/Languages/Java/Garbage_Collection.md","type":"file","children":[]},{"name":"Interfaces.md","path":"Courses/Languages/Java/Interfaces.md","type":"file","children":[]},{"name":"intro.md","path":"Courses/Languages/Java/intro.md","type":"file","children":[]},{"name":"JVM.md","path":"Courses/Languages/Java/JVM.md","type":"file","children":[]},{"name":"OOP_Concepts.md","path":"Courses/Languages/Java/OOP_Concepts.md","type":"file","children":[]},{"name":"Operators.md","path":"Courses/Languages/Java/Operators.md","type":"file","children":[]}]},{"name":"Javascript","path":"Courses/Languages/Javascript","type":"directory","children":[{"name":"javascript.md","path":"Courses/Languages/Javascript/javascript.md","type":"file","children":[]}]},{"name":"Rust","path":"Courses/Languages/Rust","type":"directory","children":[{"name":"Async.md","path":"Courses/Languages/Rust/Async.md","type":"file","children":[]},{"name":"Collections.md","path":"Courses/Languages/Rust/Collections.md","type":"file","children":[]},{"name":"Concurrency.md","path":"Courses/Languages/Rust/Concurrency.md","type":"file","children":[]},{"name":"Enums.md","path":"Courses/Languages/Rust/Enums.md","type":"file","children":[]},{"name":"Error.md","path":"Courses/Languages/Rust/Error.md","type":"file","children":[]},{"name":"Functional.md","path":"Courses/Languages/Rust/Functional.md","type":"file","children":[]},{"name":"Generics.md","path":"Courses/Languages/Rust/Generics.md","type":"file","children":[]},{"name":"lifetimes.md","path":"Courses/Languages/Rust/lifetimes.md","type":"file","children":[]},{"name":"OOP.md","path":"Courses/Languages/Rust/OOP.md","type":"file","children":[]},{"name":"Ownership.md","path":"Courses/Languages/Rust/Ownership.md","type":"file","children":[]},{"name":"Packaging.md","path":"Courses/Languages/Rust/Packaging.md","type":"file","children":[]},{"name":"Rust_Basics.md","path":"Courses/Languages/Rust/Rust_Basics.md","type":"file","children":[]},{"name":"Smart_Pointers.md","path":"Courses/Languages/Rust/Smart_Pointers.md","type":"file","children":[]},{"name":"Structs.md","path":"Courses/Languages/Rust/Structs.md","type":"file","children":[]},{"name":"Test.md","path":"Courses/Languages/Rust/Test.md","type":"file","children":[]},{"name":"Traits.md","path":"Courses/Languages/Rust/Traits.md","type":"file","children":[]}]}]},{"name":"System_Design","path":"Courses/System_Design","type":"directory","children":[{"name":"Introduction.md","path":"Courses/System_Design/Introduction.md","type":"file","children":[]}]},{"name":"Web_Dev","path":"Courses/Web_Dev","type":"directory","children":[{"name":"Redis","path":"Courses/Web_Dev/Redis","type":"directory","children":[{"name":"redis-cli.md","path":"Courses/Web_Dev/Redis/redis-cli.md","type":"file","children":[]},{"name":"redis.md","path":"Courses/Web_Dev/Redis/redis.md","type":"file","children":[]}]}]}]},{"name":"Miscellaneous","path":"Miscellaneous","type":"directory","children":[{"name":"Self-Hosting Bitwarden.md","path":"Miscellaneous/Self-Hosting Bitwarden.md","type":"file","children":[]},{"name":"The_Caret_Conundrum.md","path":"Miscellaneous/The_Caret_Conundrum.md","type":"file","children":[]}]},{"name":"University","path":"University","type":"directory","children":[{"name":"asdf","path":"University/asdf","type":"directory","children":[{"name":"hello.md","path":"University/asdf/hello.md","type":"file","children":[]}]},{"name":"Computer_Networks","path":"University/Computer_Networks","type":"directory","children":[{"name":"Module_1","path":"University/Computer_Networks/Module_1","type":"directory","children":[{"name":"bandwidth_and_multiplexing.md","path":"University/Computer_Networks/Module_1/bandwidth_and_multiplexing.md","type":"file","children":[]},{"name":"Data.md","path":"University/Computer_Networks/Module_1/Data.md","type":"file","children":[]},{"name":"OSI_model.md","path":"University/Computer_Networks/Module_1/OSI_model.md","type":"file","children":[]},{"name":"Protocols_and_Standards.md","path":"University/Computer_Networks/Module_1/Protocols_and_Standards.md","type":"file","children":[]},{"name":"Topologies.md","path":"University/Computer_Networks/Module_1/Topologies.md","type":"file","children":[]},{"name":"Transmission_Media.md","path":"University/Computer_Networks/Module_1/Transmission_Media.md","type":"file","children":[]},{"name":"Wired_LAN.md","path":"University/Computer_Networks/Module_1/Wired_LAN.md","type":"file","children":[]},{"name":"Wireless_LAN.md","path":"University/Computer_Networks/Module_1/Wireless_LAN.md","type":"file","children":[]}]}]},{"name":"Data_Mining","path":"University/Data_Mining","type":"directory","children":[{"name":"Module_1","path":"University/Data_Mining/Module_1","type":"directory","children":[{"name":"Data Mining.md","path":"University/Data_Mining/Module_1/Data Mining.md","type":"file","children":[]},{"name":"Data Preprocessing.md","path":"University/Data_Mining/Module_1/Data Preprocessing.md","type":"file","children":[]},{"name":"Intro.md","path":"University/Data_Mining/Module_1/Intro.md","type":"file","children":[]},{"name":"KDD.md","path":"University/Data_Mining/Module_1/KDD.md","type":"file","children":[]},{"name":"OLAP.md","path":"University/Data_Mining/Module_1/OLAP.md","type":"file","children":[]},{"name":"WareHouse_Schema.md","path":"University/Data_Mining/Module_1/WareHouse_Schema.md","type":"file","children":[]}]},{"name":"Module_2","path":"University/Data_Mining/Module_2","type":"directory","children":[{"name":"Advanced Pattern Mining.md","path":"University/Data_Mining/Module_2/Advanced Pattern Mining.md","type":"file","children":[]},{"name":"Association Rule Mining.md","path":"University/Data_Mining/Module_2/Association Rule Mining.md","type":"file","children":[]},{"name":"Associations and Correlations.md","path":"University/Data_Mining/Module_2/Associations and Correlations.md","type":"file","children":[]},{"name":"Cluster Analysis.md","path":"University/Data_Mining/Module_2/Cluster Analysis.md","type":"file","children":[]},{"name":"Clustering with constriants.md","path":"University/Data_Mining/Module_2/Clustering with constriants.md","type":"file","children":[]},{"name":"Density Based Methods.md","path":"University/Data_Mining/Module_2/Density Based Methods.md","type":"file","children":[]},{"name":"Frequent Pattern Mining.md","path":"University/Data_Mining/Module_2/Frequent Pattern Mining.md","type":"file","children":[]},{"name":"Hierarchical Methods.md","path":"University/Data_Mining/Module_2/Hierarchical Methods.md","type":"file","children":[]},{"name":"Outlier Detection.md","path":"University/Data_Mining/Module_2/Outlier Detection.md","type":"file","children":[]},{"name":"Sequential Pattern mining.md","path":"University/Data_Mining/Module_2/Sequential Pattern mining.md","type":"file","children":[]},{"name":"Similarity and Distance Measure.md","path":"University/Data_Mining/Module_2/Similarity and Distance Measure.md","type":"file","children":[]}]}]},{"name":"Economics","path":"University/Economics","type":"directory","children":[{"name":"Module_1.md","path":"University/Economics/Module_1.md","type":"file","children":[]},{"name":"Module_3.md","path":"University/Economics/Module_3.md","type":"file","children":[]}]},{"name":"OOP","path":"University/OOP","type":"directory","children":[{"name":"Module_1","path":"University/OOP/Module_1","type":"directory","children":[{"name":"Basic_Concepts.md","path":"University/OOP/Module_1/Basic_Concepts.md","type":"file","children":[]},{"name":"Intro.md","path":"University/OOP/Module_1/Intro.md","type":"file","children":[]}]},{"name":"Module_1.md","path":"University/OOP/Module_1.md","type":"file","children":[]}]},{"name":"asdf.md","path":"University/asdf.md","type":"file","children":[]}]},{"name":"index.md","path":"index.md","type":"file","children":[]}]'))}catch(e){console.error("Error parsing file tree:",e)}toggleTheme(),initializeCopyButton(),toggleKeyHints(),keybindingInitialize(),await initializeSearch();var e=document.getElementById("search-input");e.addEventListener("input",handleSearch),e.addEventListener("keydown",function(e){"Escape"===e.key&&closeSearch()})}),document.addEventListener("keydown",function(e){if("INPUT"!==e.target.tagName&&"TEXTAREA"!==e.target.tagName&&!e.target.isContentEditable){var t=e.key.toLowerCase();switch(window.lastGPress||(window.lastGPress={count:0,time:0}),t){case"j":e.preventDefault(),window.scrollBy(0,50);break;case"k":e.preventDefault(),window.scrollBy(0,-50);break;case"g":e.shiftKey?(e.preventDefault(),window.scrollTo(0,document.body.scrollHeight)):(n=Date.now())-window.lastGPress.time<500&&1===window.lastGPress.count?(e.preventDefault(),window.scrollTo(0,0),window.lastGPress.count=0):(window.lastGPress.count=1,window.lastGPress.time=n);break;case"u":e.ctrlKey&&(e.preventDefault(),window.scrollBy(0,-window.innerHeight/2));break;case"d":e.ctrlKey&&(e.preventDefault(),window.scrollBy(0,window.innerHeight/2));break;case"r":e.ctrlKey&&(e.preventDefault(),window.location.reload());break;case"/":e.preventDefault(),openSearch();break;case"escape":document.activeElement&&document.activeElement.blur();var n=document.querySelector(".keybinding");n&&!n.classList.contains("hidden")&&n.classList.add("hidden");break;case"home":e.preventDefault(),window.scrollTo(0,0);break;case"end":e.preventDefault(),window.scrollTo(0,document.body.scrollHeight);break;case"h":e.shiftKey&&(e.preventDefault(),toggleKeyHints());break;case"t":e.shiftKey&&(e.preventDefault(),toggleTheme(!0))}}}),document.getElementById("search-dialog").addEventListener("click",function(e){e.target===this&&closeSearch()});let searchIndex=[],fuse=null;async function initializeSearch(){try{var e=await fetch("/static/search-index.json");if(!e.ok)throw new Error(`Failed to fetch search index: ${e.status} `+e.statusText);if(searchIndex=await e.json(),!Array.isArray(searchIndex))throw new Error("Search index is not an array");fuse=new Fuse(searchIndex,{keys:[{name:"content",weight:.7},{name:"name",weight:.3}],threshold:.4,distance:100,includeScore:!0,includeMatches:!0,useExtendedSearch:!0,ignoreLocation:!0,minMatchCharLength:2}),console.log("Search initialized successfully with",searchIndex.length,"items")}catch(e){console.error("Error initializing search:",e),document.getElementById("search-results").innerHTML='<p class="search-error">Search initialization failed. Please try refreshing the page.</p>'}}</script> </body> </html> 